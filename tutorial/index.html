<!DOCTYPE html>
<html><head>
    <link rel="icon" href="/logo.svg">
    <title>VanJS - Tutorial and API Reference</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/w3.css">
    <link rel="stylesheet" href="/font.css">
    <link rel="stylesheet" href="/prism.css">
    <link rel="stylesheet" href="/vanjs.css">
  </head>
  <body class="line-numbers" data-prismjs-copy="üìã">
    <!-- Google tag (gtag.js) -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Q0NB75RY7E"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-Q0NB75RY7E');
    </script>
    <!-- Sidebar/menu -->
    <nav class="w3-sidebar w3-red w3-collapse w3-top w3-large w3-padding" style="z-index:3;width:280px;font-weight:bold;" id="mySidebar"><br>
      <a href="javascript:void(0)" onclick="w3_close()" class="w3-button w3-hide-large w3-display-topleft" style="width:100%;font-size:22px">Close Menu</a>
      <div class="w3-container">
        <h1 class="w3-padding-16 w3-xxxlarge">
          <img src="/logo.svg" alt="VanJS" width="192px" height="192px">
        </h1>
      </div>
      <div id="nav" class="w3-bar-block"><a href="/" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Home</a><a href="/start" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Getting Started</a><a href="/tutorial" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white current">Tutorial</a><a href="/demo" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">VanJS by Example</a><a href="/convert" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Convert HTML to VanJS</a><a href="/minivan" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Mini-Van</a><a href="/advanced" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Advanced Topics</a><a href="/media" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Media Mentions</a><a href="/about" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">About</a></div>
    </nav>

    <!-- Top menu on small screens -->
    <header class="w3-container w3-top w3-hide-large w3-red w3-xlarge w3-padding">
      <a href="javascript:void(0)" class="w3-button w3-red w3-margin-right" onclick="w3_open()">‚ò∞</a>
      <span id="title-bar">VanJS Tutorial</span>
    </header>

    <!-- Overlay effect when opening sidebar on small screens -->
    <div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

    <!-- !PAGE CONTENT! -->
    <div class="w3-main" style="margin-left:300px;">
      <div id="page">
        <div id="content"><h1 class="w3-xxlarge"><b>VanJS</b>: Tutorial and API Reference</h1><p>In this tutorial, we will break down into 3 core functionality <b>VanJS</b> supports: DOM composition / manipulation, State and State binding.</p><h2 class="w3-xxlarge w3-text-red" id="dom"><a class="self-link" href="#dom">DOM Composition and Manipulation</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><h3 class="w3-large w3-text-red" id="your-first-vanjs-app-a-simple-hello-page"><a class="self-link" href="#your-first-vanjs-app-a-simple-hello-page">Your first VanJS app: a simple <code class="symbol">Hello</code> page</a></h3><p>We will start this tutorial with a simple <code class="symbol">Hello</code> page, with the code below:</p><pre><code class="language-js">const {a, div, li, p, ul} = van.tags

const Hello = () =&gt; div(
  p("üëãHello"),
  ul(
    li("üó∫Ô∏èWorld"),
    li(a({href: "https://vanjs.org/"}, "üç¶VanJS")),
  ),
)

van.add(document.body, Hello())
</code></pre><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/hello">Try on jsfiddle</a></p><p>The code should be self-explanatory if you have some familiarity with HTML. Unlike React, everything in the code above is just pure JavaScript, meaning that you are simply calling functions from <code class="symbol">van.js</code> without any transpiling that converts your source code into another form. Reusable UI components built with <b>VanJS</b> can be pure vanilla JavaScript functions as well. Here we capitalize the first letter to follow React conventions.</p><p>Also unlike React, <b>VanJS</b> does not introduce an ad-hoc virtual DOM layer. All the tag functions above directly return the created DOM objects. e.g.: the function call <code class="symbol">p("üëãHello")</code> simply creates an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLParagraphElement" class="w3-hover-opacity">HTMLParagraphElement</a></code> with <code class="symbol">üëãHello</code> as its <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText" class="w3-hover-opacity">innerText</a></code>, meaning that you can directly interact with your created DOM nodes with native DOM APIs.</p><h3 class="w3-large w3-text-red" id="api-tags"><a class="self-link" href="#api-tags">API reference: <code class="symbol">van.tags</code></a></h3><p><code class="symbol">van.tags</code> is a top-level dynamic object in <b>VanJS</b> implemented with <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" class="w3-hover-opacity">Proxy</a></code>. <code class="symbol">van.tags.&lt;name&gt;</code> gets you a function that creates an HTML element with tag name <code class="symbol">&lt;name&gt;</code>. A common way of using <code class="symbol">van.tags</code> is like the line below:</p><pre><code class="language-js">const {a, div, p} = van.tags</code></pre><p>With the line, <code class="symbol">a</code>, <code class="symbol">div</code>, <code class="symbol">p</code> are functions that create <code class="symbol">&lt;a&gt;</code>, <code class="symbol">&lt;div&gt;</code>, <code class="symbol">&lt;p&gt;</code> HTML elements respectively.</p><p>We will use <code class="symbol">div</code> function as an example, the API reference for <code class="symbol">div</code> tag function is as below:</p><table><tbody><tr><td><b>Signature</b></td><td><code class="language-js">div([props], ...children) =&gt; &lt;the created DOM element&gt;</code></td></tr><tr><td><b>Description</b></td><td>Creates an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement" class="w3-hover-opacity">HTMLDivElement</a></code> with <code class="symbol">props</code> as its properties and <code class="symbol">children</code> as its child nodes.</td></tr><tr><td><b>Parameters</b></td><td><ul><li><b><code class="symbol">props</code></b> - optional, a plain JavaScript object whose keys and values are the keys and values of the properties of the created HTML element. Keys should be <code class="symbol">string</code>, and values can be primitives (<code class="symbol">string</code>, <code class="symbol">number</code>, <code class="symbol">boolean</code> or <code class="symbol">bigint</code>), primitive-valued <code class="symbol">State</code> objects, or <code class="symbol">State</code>-derived properties. We will explain the behavior of <a href="#state-typed-prop" class="w3-hover-opacity"><code class="symbol">State</code>-typed</a> and <a href="#state-derived-prop" class="w3-hover-opacity"><code class="symbol">State</code>-derived</a> properties in State Binding section below. For keys like <code class="symbol">on...</code>, value should be <code class="symbol">function</code> to represent the event handler.</li><li><b><code class="symbol">children</code></b> - caller can provide 0 or more children as arguments to represent the child nodes of the created HTML element. Each child can be a valid DOM node, a primitive (<code class="symbol">string</code>, <code class="symbol">number</code>, <code class="symbol">boolean</code> or <code class="symbol">bigint</code>), <code class="symbol">null</code>, <code class="symbol">undefined</code>, a primitive-valued or <code class="symbol">null</code>/<code class="symbol">undefined</code>-valued <code class="symbol">State</code> object, or an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="w3-hover-opacity">Array</a></code> of children. <code class="symbol">null</code>/<code class="symbol">undefined</code>-valued children are only allowed in <a href="https://github.com/vanjs-org/van/discussions/53#discussioncomment-6137688" class="w3-hover-opacity">0.12.1</a> or later and will be ignored. A <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Text" class="w3-hover-opacity">Text node</a></code> will be created for each primitive-typed argument. We will explain the behavior of <a href="#state-typed-child" class="w3-hover-opacity"><code class="symbol">State</code>-typed child</a> in State Binding section below. For DOM node, it shouldn't be already connected to a document tree (<code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected" class="w3-hover-opacity">isConnected</a></code> property should be <code class="symbol">false</code>). i.e.: You should not declare an existing DOM node in the current document as the child node of the newly created element.</li></ul></td></tr><tr><td><b>Returns</b></td><td>The <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement" class="w3-hover-opacity">HTMLDivElement</a></code> object just created.</td></tr></tbody></table><h3 class="w3-large w3-text-red" id="svg-and-mathml-support"><a class="self-link" href="#svg-and-mathml-support">SVG and MathML Support</a></h3><div style="font-size: 0.9em;"><i>Requires <b>VanJS</b> <a href="https://github.com/vanjs-org/van/discussions/53" class="w3-hover-opacity">0.12.0</a> or later.</i></div><p>HTML elements with <code class="symbol"><a href="https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/glossary.html#dt-namespaceURI" class="w3-hover-opacity">namespace URI</a></code>&nbsp;can be created via <code class="symbol"><a href="#api-tagsns" class="w3-hover-opacity">van.tagsNS</a></code>, a variant of <code class="symbol">van.tags</code> that allows you to specify the <code class="symbol">namespaceURI</code> of the created elements. Here is an example of composing the SVG DOM tree with <code class="symbol">van.tagsNS</code>:</p><pre><code class="language-js">const {circle, path, svg} = van.tagsNS("http://www.w3.org/2000/svg")

const Smiley = () =&gt; svg({width: "16px", viewBox: "0 0 50 50"},
  circle({cx: "25", cy: "25", "r": "20", stroke: "black", "stroke-width": "2", fill: "yellow"}),
  circle({cx: "16", cy: "20", "r": "2", stroke: "black", "stroke-width": "2", fill: "black"}),
  circle({cx: "34", cy: "20", "r": "2", stroke: "black", "stroke-width": "2", fill: "black"}),
  path({"d": "M 15 30 Q 25 40, 35 30", stroke: "black", "stroke-width": "2", fill: "transparent"}),
)

van.add(document.body, Smiley())
</code></pre><p><b>Demo:</b> <span id="demo-smiley"></span></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/smiley">Try on jsfiddle</a></p><p>Similarly, math formulas can be created with <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/MathML/Element" class="w3-hover-opacity">MathML</a></code>&nbsp;elements via <code class="symbol">van.tagsNS</code>:</p><pre><code class="language-js">const {math, mi, mn, mo, mrow, msup} = van.tagsNS("http://www.w3.org/1998/Math/MathML")

const Euler = () =&gt; math(
  msup(mi("e"), mrow(mi("i"), mi("œÄ"))), mo("+"), mn("1"), mo("="), mn("0"),
)

van.add(document.body, Euler())
</code></pre><p><b>Demo:</b> <span id="demo-euler"></span></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/euler">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="api-tagsns"><a class="self-link" href="#api-tagsns">API reference: <code class="symbol">van.tagsNS</code></a></h3><div style="font-size: 0.9em;"><i>Requires <b>VanJS</b> <a href="https://github.com/vanjs-org/van/discussions/53" class="w3-hover-opacity">0.12.0</a> or later.</i></div><table><tbody><tr><td><b>Signature</b></td><td><code class="language-js">van.tagsNS(namespaceURI) =&gt; &lt;the created tags object for elements with specified namespaceURI&gt;</code></td></tr><tr><td><b>Description</b></td><td>Creates a tags <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" class="w3-hover-opacity">Proxy</a></code> object similar to <code class="symbol"><a href="#api-tags" class="w3-hover-opacity">van.tags</a></code> for elements with specified <code class="symbol">namespaceURI</code>.</td></tr><tr><td><b>Parameters</b></td><td><ul><li><b><code class="symbol">namespaceURI</code></b> - a string for the <code class="symbol">namespaceURI</code> property of elements created via tag fucntions.</li></ul></td></tr><tr><td><b>Returns</b></td><td>The created tags object.</td></tr></tbody></table><h3 class="w3-large w3-text-red" id="api-add"><a class="self-link" href="#api-add">API reference: <code class="symbol">van.add</code></a></h3><p><code class="symbol">van.add</code> fucntion is similar to tag functions described above. Instead of creating a new HTML element with specified properties and children, <code class="symbol">van.add</code> function mutates its first argument (which is an existing <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" class="w3-hover-opacity">Element node</a></code>) by appending 0 or more children with <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild" class="w3-hover-opacity">appendChild</a></code> calls:</p><table><tbody><tr><td><b>Signature</b></td><td><code class="language-js">van.add(dom, ...children) =&gt; dom</code></td></tr><tr><td><b>Description</b></td><td>Mutates <code class="symbol">dom</code> by appending 0 or more child nodes to it. Returns  <code class="symbol">dom</code> for possibly further chaining.</td></tr><tr><td><b>Parameters</b></td><td><ul><li><b><code class="symbol">dom</code></b> - an existing DOM element that we want to append children to.</li><li><b><code class="symbol">children</code></b> - caller can provide 0 or more <code class="symbol">children</code> as arguments to represent the child nodes we want to append to <code class="symbol">dom</code>. Each child can be a valid DOM node, a primitive, <code class="symbol">null</code>, <code class="symbol">undefined</code>, a primitive-valued or <code class="symbol">null</code>/<code class="symbol">undefined</code>-valued <code class="symbol">State</code> object, or an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="w3-hover-opacity">Array</a></code> of children. <code class="symbol">null</code>/<code class="symbol">undefined</code>-valued children are only allowed in <a href="https://github.com/vanjs-org/van/discussions/53#discussioncomment-6137688" class="w3-hover-opacity">0.12.1</a> or later and will be ignored. A <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Text" class="w3-hover-opacity">Text node</a></code> will be created for each primitive-typed argument. <a href="#state-typed-child" class="w3-hover-opacity"><code class="symbol">State</code>-typed child</a> behave the same way as in tag function. For DOM node, it shouldn't be already connected to a document tree (<code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected" class="w3-hover-opacity">isConnected</a></code> property should be <code class="symbol">false</code>). i.e.: You should not append an existing DOM node in the current document to <code class="symbol">dom</code>. If 0 children is provided, this function is a no-op.</li></ul></td></tr><tr><td><b>Returns</b></td><td><code class="symbol">dom</code></td></tr></tbody></table><h3 class="w3-large w3-text-red" id="dom-nodes-already-in-the-document-tree-can-t-be-used-as-children"><a class="self-link" href="#dom-nodes-already-in-the-document-tree-can-t-be-used-as-children">DOM nodes already in the document tree can't be used as <code class="symbol">children</code></a></h3><p>As mentioned in the API reference, if a DOM node is already connected to the document tree, it shouldn't be used as the child node of tag function or <code class="symbol">van.add</code>. The following code is invalid and an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="w3-hover-opacity">Error</a></code> will be thrown when <code class="symbol">van-&lt;version&gt;.debug.js</code> is being used:</p><pre><code class="language-js">const existing = document.getElementById("some-id")

// Invalid! Existing node can't be used as the child node of tag function.
const dom = div({id: "new-id"}, existing)

// Invalid! Existing node can't be appended to other nodes in `van.add`.
van.add(document.body, existing)</code></pre><h3 class="w3-large w3-text-red" id="fun-dom"><a class="self-link" href="#fun-dom">Functional-style DOM tree building</a></h3><p>Because both tag functions and <code class="symbol">van.add</code> can take <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="w3-hover-opacity">Array</a></code> arguments and the <code class="symbol">Array</code> arguments can be deeply nested. <b>VanJS</b> enables very ergonomic DOM tree composition in functional-style. See examples below:</p><p>Building a bullet list:</p><pre><code class="language-js">const {li, ul} = van.tags

const List = ({items}) =&gt; ul(items.map(it =&gt; li(it)))

van.add(document.body, List({items: ["Item 1", "Item 2", "Item 3"]}))
</code></pre><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/list">Try on jsfiddle</a></p><p>Building a table:</p><pre><code class="language-js">const {table, tbody, thead, td, th, tr} = van.tags

const Table = ({head, data}) =&gt; table(
  head ? thead(tr(head.map(h =&gt; th(h)))) : [],
  tbody(data.map(row =&gt; tr(
    row.map(col =&gt; td(col)),
  ))),
)

van.add(document.body, Table({
  head: ["ID", "Name", "Country"],
  data: [
    [1, "John Doe", "US"],
    [2, "Jane Smith", "CA"],
    [3, "Bob Johnson", "AU"],
  ],
}))
</code></pre><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/table">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="on-event-handlers"><a class="self-link" href="#on-event-handlers"><code class="symbol">on...</code> event handlers</a></h3><p>In tag functions, you can provide a <code class="symbol">function</code> value for property keys like <code class="symbol">on...</code>. This is a convenient way to specify event handlers. For instance, the code below creates a <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button" class="w3-hover-opacity">button</a></code> that shows an alert whenever clicked:</p><pre><code class="language-js">button({onclick: () =&gt; alert("Hello from üç¶VanJS")}, "Hello")</code></pre><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/onclick">Try on jsfiddle</a></p><p>üéâ Congratulations! You have mastered the skills for building and manipulating DOM trees using <b>VanJS</b>'s declarative API, which is incredibly powerful for creating comprehensive applications with elegant code. In the sections below, you will continue to learn how to build reactive applications with state and state binding.</p><p>If your application doesn't rely on state and state binding, you can use the slimmed-down version of <b>VanJS</b> - <a href="/minivan" class="w3-hover-opacity">Mini-Van</a>.</p><h2 class="w3-xxlarge w3-text-red" id="state"><a class="self-link" href="#state">State</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>A <code class="symbol">State</code> object in <b>VanJS</b> represents a value that can be updated throughout your application. A <code class="symbol">State</code> object has a public property <code class="symbol">val</code>, with a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" class="w3-hover-opacity">custom setter</a> that automatically propogates changes to DOM nodes that bind to it. In addition, you can register your event handler to listen to updates of a <code class="symbol">State</code> object via its <code class="symbol">onnew</code> method.</p><p>The code below illustrates how a <code class="symbol">State</code> object can be used:</p><pre><code class="language-js">const {button, div, input, sup} = van.tags

// Create a new State object with init value 1
const counter = van.state(1)

// Log whenever the value of the state is updated
counter.onnew((v, oldV) =&gt; console.log(`Counter: ${oldV} -&gt; ${v}`))

// Used as a child node
const dom1 = div(counter)

// Used as a property
const dom2 = input({type: "number", value: counter, disabled: true})

// Used in a state-derived property
const dom3 = div(
  {style: {deps: [counter], f: c =&gt; `font-size: ${c}em;`}},
  "Text")

// Used in a complex binding
const dom4 = van.bind(counter, c =&gt; div(c, sup(2), ` = ${c * c}`))

// Button to increment the value of the state
const incrementBtn = button({onclick: () =&gt; ++counter.val}, "Increment")
const resetBtn = button({onclick: () =&gt; counter.val = 1}, "Reset")

van.add(document.body, incrementBtn, resetBtn, dom1, dom2, dom3, dom4)
</code></pre><p><b>Demo:</b></p><p id="demo-state"></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/state">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="api-state"><a class="self-link" href="#api-state">API reference: <code class="symbol">van.state</code></a></h3><table><tbody><tr><td><b>Signature</b></td><td><code class="language-js">van.state(initVal) =&gt; &lt;the created State object&gt;</code></td></tr><tr><td><b>Description</b></td><td>Creates a <code class="symbol">State</code> object with its init value specified in the argument.</td></tr><tr><td><b>Parameters</b></td><td><ul><li><b><code class="symbol">initVal</code></b> - the init value of the <code class="symbol">State</code> object to be created.</li></ul></td></tr><tr><td><b>Returns</b></td><td>The created <code class="symbol">State</code> object.</td></tr></tbody></table><h3 class="w3-large w3-text-red" id="public-interface-of-state-objects"><a class="self-link" href="#public-interface-of-state-objects">Public interface of <code class="symbol">State</code> objects</a></h3><ul><li>Property <code class="symbol"><b>val</b></code> - the current value of the <code class="symbol">State</code> object. When a new value of this property is set, all event handlers registered via <code class="symbol">onnew</code> method will be called and all DOM nodes that bind to it will be updated accordingly. Note that: while setting <code class="symbol">val</code>, if the provided value is the same as the current one, event handlers and DOM updates will be skipped.</li><li>Method <code class="symbol"><b>onnew(l)</b></code> - register an event handler to listen to the updates of the <code class="symbol">State</code> object. Whenever a new value is assigned to the state, the event handler <code class="symbol">l</code> will be called with 2 arguments: <code class="symbol">v</code> and <code class="symbol">oldV</code>, representing the new and old value of the state.</li></ul><p>The value of a <code class="symbol">State</code> object can be almost anything, primitive, <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="w3-hover-opacity">Object</a></code>, <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="w3-hover-opacity">Array</a></code>, <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null" class="w3-hover-opacity">null</a></code>, etc., with 2 ad-hoc exceptions that we made: The value of the <code class="symbol">State</code> object cannot be a DOM node, or another <code class="symbol">State</code> object. Having values in these 2 types carries little semantic information and is more likely a result of coding bugs. Thus we disallow <code class="symbol">State</code> objects to have values in these 2 types. In <code class="symbol">van-{version}.debug.js</code>, an explicit error will be thrown if you try to assign a DOM node or another <code class="symbol">State</code> object as the value of a state.</p><h3 class="w3-large w3-text-red" id="state-val-is-immutable"><a class="self-link" href="#state-val-is-immutable"><code class="symbol">State.val</code> is immutable</a></h3><p>While you can update <code class="symbol">State</code> objects by setting the <code class="symbol">val</code> property, you should never mutate the underlying object of <code class="symbol">val</code> itself. Doing so will not trigger the DOM tree update as you would expect and might result in <a href="https://en.wikipedia.org/wiki/Undefined_behavior" class="w3-hover-opacity">undefined behavior</a> due to <a href="https://en.wikipedia.org/wiki/Aliasing_(computing)" class="w3-hover-opacity">aliasing</a>. In <code class="symbol">van-&lt;version&gt;.debug.js</code>, attempt to mutate the object in <code class="symbol">val</code> will lead to an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="w3-hover-opacity">Error</a></code> to be thrown.</p><h2 class="w3-xxlarge w3-text-red" id="state-binding"><a class="self-link" href="#state-binding">State Binding</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>Once <code class="symbol">State</code> objects are created, we can bind them to DOM nodes in various ways to make your UI reactive to state changes.</p><h3 class="w3-large w3-text-red" id="state-typed-child"><a class="self-link" href="#state-typed-child"><code class="symbol">State</code> objects as child nodes</a></h3><p><code class="symbol">State</code> objects can be used as child nodes in <code class="symbol"><a href="#api-tags" class="w3-hover-opacity">tag functions</a></code> and <code class="symbol"><a href="#api-add" class="w3-hover-opacity">van.add</a></code>, like the <code class="symbol"><a href="/#code-counter" class="w3-hover-opacity">Counter</a></code> example shown in the home page. For a <code class="symbol">State</code> object used as a child node, its value needs to be primitive (<code class="symbol">string</code>, <code class="symbol">number</code>, <code class="symbol">boolean</code> or <code class="symbol">bigint</code>), and a <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Text" class="w3-hover-opacity">Text node</a></code> will be created for it. The content of the created <code class="symbol">Text node</code> will be always in sync with the value of the state.</p><p>The following code shows how to build a simple timer with this feature:</p><pre><code class="language-js">const {button, span} = van.tags

const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

const Timer = ({totalSecs}) =&gt; {
  const secs = van.state(totalSecs);
  return span(
    secs, "s ",
    button({onclick: async () =&gt; {
      while (secs.val &gt; 0) await sleep(1000), --secs.val
      await sleep(10) // Wait briefly for DOM update
      alert("‚è∞: Time is up")
      secs.val = totalSecs
    }}, "Start"),
  )
}

van.add(document.body, Timer({totalSecs: 5}))
</code></pre><p><b>Demo:</b> <span id="demo-timer"></span></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/timer">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="state-typed-prop"><a class="self-link" href="#state-typed-prop"><code class="symbol">State</code> objects as properties</a></h3><p><code class="symbol">State</code> objects can be used as properties of HTML elements. Similar to <code class="symbol">State</code>-based child nodes, the value of the properties will be always in sync with the value of the respective states. When <code class="symbol">State</code> objects are used as properties, you need to make sure that the values of the states are always valid property values, i.e.: primitives or <code class="symbol">function</code>s (for event handlers).</p><p>The following code demonstrates 2 <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/text" class="w3-hover-opacity">text inputs</a></code> whose values are always in sync:</p><pre><code class="language-js">const {input, span} = van.tags

const ConnectedProps = () =&gt; {
  const text = van.state("")
  return span(
    input({type: "text", value: text, oninput: e =&gt; text.val = e.target.value}),
    input({type: "text", value: text, oninput: e =&gt; text.val = e.target.value}),
  )
}

van.add(document.body, ConnectedProps())
</code></pre><p><b>Demo:</b> <span id="demo-connected-props"></span></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/connected-props">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="state-derived-prop"><a class="self-link" href="#state-derived-prop"><code class="symbol">State</code>-derived properties</a></h3><p><code class="symbol">State</code>-derived property is a more advanced way to bind a property of an HTML element with one or more underlying <code class="symbol">State</code> objects. To use <code class="symbol">State</code>-derived properties, you need to provide an object with the following fields as the value in <code class="symbol">props</code> argument while calling to a <code class="symbol"><a href="#api-tags" class="w3-hover-opacity">tag function</a></code>:</p><ul><li><code class="symbol"><b>deps</b></code> - an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="w3-hover-opacity">Array</a></code> of one or more dependencies.</li><li><code class="symbol"><b>f</b></code> - a <code class="symbol">function</code> that takes the values of states in <code class="symbol"><b>deps</b></code> as parameters. The return value of <code class="symbol"><b>f</b></code> should always be valid property values, i.e.: primitives or <code class="symbol">function</code>s (for event handlers).</li></ul><p>The example below is a live font size and color preview implemented with this feature:</p><pre><code class="language-js">const {input, option, select, span} = van.tags

const FontPreview = () =&gt; {
  const size = van.state(16), color = van.state("black")
  return span(
    "Size: ",
    input({type: "range", min: 10, max: 36, value: size,
      oninput: e =&gt; size.val = e.target.value}),
    " Color: ",
    select({oninput: e =&gt; color.val = e.target.value, value: color},
      ["black", "blue", "green", "red", "brown"]
        .map(c =&gt; option({value: c}, c)),
    ),
    span({style: {deps: [size, color], f: (size, color) =&gt;
      `font-size: ${size}px; color: ${color};`}}, " Hello üç¶VanJS"),
  )
}

van.add(document.body, FontPreview())
</code></pre><p><b>Demo:</b> <span id="demo-font-preview"></span></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/font-preview">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="complex-state-binding"><a class="self-link" href="#complex-state-binding">Complex <code class="symbol">State</code> binding</a></h3><p>You can call <code class="symbol"><a href="#api-bind" class="w3-hover-opacity">van.bind</a></code> to bind an HTML node with one or more <code class="symbol">State</code> objects in a custom way, as specified in a generation function that you provide. The following example illustrates this:</p><pre><code class="language-js">const {input, li, option, select, span, ul} = van.tags

const SortedList = () =&gt; {
  const items = van.state("a,b,c"), sortedBy = van.state("Ascending")
  return span(
    "Comma-separated list: ",
    input({oninput: e =&gt; items.val = e.target.value,
      type: "text", value: items}), " ",
    select({oninput: e =&gt; sortedBy.val = e.target.value, value: sortedBy},
      option({value: "Ascending"}, "Ascending"),
      option({value: "Descending"}, "Descending"),
    ),
    van.bind(items, sortedBy, (items, sortedBy) =&gt;
      sortedBy === "Ascending" ?
        ul(items.split(",").sort().map(i =&gt; li(i))) :
        ul(items.split(",").sort().reverse().map(i =&gt; li(i)))),
  )
}

van.add(document.body, SortedList())
</code></pre><p><b>Demo:</b></p><p id="demo-sorted-list"></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/sorted-list">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="api-bind"><a class="self-link" href="#api-bind">API reference: <code class="symbol">van.bind</code></a></h3><table><tbody><tr><td><b>Signature</b></td><td><code class="language-js">van.bind(dep1, dep2, ..., depN, f) =&gt; &lt;the created DOM node&gt;</code></td></tr><tr><td><b>Description</b></td><td>Creates a DOM node that binds to dependencies: <code class="symbol">dep1</code>, <code class="symbol">dep2</code>, ..., <code class="symbol">depN</code>. Whenever the values of these states change, the generation function - <code class="symbol">f</code>, will be called to update the DOM tree.</td></tr><tr><td><b>Parameters</b></td><td><ul><li><code class="symbol"><b>dep1</b></code>, <code class="symbol"><b>dep2</b></code>, ..., <code class="symbol"><b>depN</b></code> - the dependencies bound to the DOM node.</li><li><b><code class="symbol">f</code></b> - The generation function, with signature <code class="language-js">f(v1, v2, ..., vN, [dom, oldV1, oldV2, ..., oldVN]) =&gt; &lt;primitive, DOM node, null or undefined&gt;</code>. Whenever any value of <code class="symbol">dep1</code>, <code class="symbol">dep2</code>, ..., <code class="symbol">depN</code> changes, <code class="symbol">f</code> will be called and returns the new version of the DOM node based on new values of the dependencies. Optionally, <code class="symbol">f</code> can take <code class="symbol">dom</code> (the current version of the bound DOM node) and <code class="symbol">oldV1</code>, <code class="symbol">oldV2</code>, ...,<code class="symbol">oldVN</code> (the old values of the dependencies) as additional parameters to enable <a href="#stateful-binding" class="w3-hover-opacity">Stateful binding</a>, which might sometimes choose to mutate existing DOM node instead of generating a new one as an optimization. When <code class="symbol">f</code> returns a primitive, a <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Text" class="w3-hover-opacity">Text node</a></code> will be created based on its content. When <code class="symbol">f</code> returns <code class="symbol">null</code> or <code class="symbol">undefined</code>, the DOM node will removed. Removed DOM node will never be brought back, even when <code class="symbol">f</code> would return a non-<code class="symbol">null</code>/<code class="symbol">undefined</code> value based on future values of the dependencies.</li></ul></td></tr><tr><td><b>Returns</b></td><td>The created DOM node that binds to dependencies.</td></tr></tbody></table><h3 class="w3-large w3-text-red" id="polymorphism-between-state-and-non-state-dependencies"><a class="self-link" href="#polymorphism-between-state-and-non-state-dependencies">Polymorphism between <code class="symbol">State</code> and non-<code class="symbol">State</code> dependencies</a></h3><div style="font-size: 0.9em;"><i>Requires <b>VanJS</b> <a href="https://github.com/vanjs-org/van/discussions/53" class="w3-hover-opacity">0.12.0</a> or later.</i></div><p>State-derived properties and <code class="symbol">van.bind</code> can accept both <code class="symbol">State</code> and non-<code class="symbol">State</code> objects as dependency arguments. This polymorphism makes it handy to build reusable components where users can specify both state and non-state property values. Non-state dependencies behave the same way as state dependencies whose <code class="symbol">val</code> properties never change. Below is an example of a reuseable button whose <code class="symbol">color</code>, <code class="symbol">text</code> and <code class="symbol">onclick</code> properties can be both state and non-state objects:</p><pre><code class="language-js">const {button, span} = van.tags

const Button = ({color, text, onclick}) =&gt; button({
  style: {deps: [color], f: color =&gt; `background-color: ${color};`},
  onclick,
}, text)

const App = () =&gt; {
  const colorState = van.state("green")
  const textState = van.state("Turn Red")

  const turnRed = () =&gt; {
    colorState.val = "red"
    textState.val = "Turn Green"
    onclickState.val = turnGreen
  }
  const turnGreen = () =&gt; {
    colorState.val = "green"
    textState.val = "Turn Red"
    onclickState.val = turnRed
  }
  const onclickState = van.state(turnRed)

  return span(
    Button({color: "yellow", text: "Click Me", onclick: () =&gt; alert("Clicked")}), " ",
    Button({color: colorState, text: textState, onclick: onclickState}),
  )
}

van.add(document.body, App())
</code></pre><p><b>Demo:</b><span id="demo-nonstate-deps"></span></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/nonstate-deps">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="removing-a-dom-node"><a class="self-link" href="#removing-a-dom-node">Removing a DOM node</a></h3><p>As noted in the API reference above, when generation function <code class="symbol">f</code> returns <code class="symbol">null</code> or <code class="symbol">undefined</code>, the DOM node will removed. Removed DOM node will never be brought back, even when <code class="symbol">f</code> would return a non-<code class="symbol">null</code>/<code class="symbol">undefined</code> value based on future values of the dependencies.</p><p>The following code illustrates how to build an editable list with this features:</p><pre><code class="language-js">const {a, button, div, input, li, ul} = van.tags

const ListItem = ({text}) =&gt; {
  const deleted = van.state(false)
  return van.bind(deleted, d =&gt; d ? null : li(
    text, a({onclick: () =&gt; deleted.val = true}, "‚ùå"),
  ))
}

const EditableList = () =&gt; {
  const listDom = ul()
  const textDom = input({type: "text"})
  return div(
    textDom, " ", button({
      onclick: () =&gt; van.add(listDom, ListItem({text: textDom.value})),
    }, "‚ûï"),
    listDom,
  )
}

van.add(document.body, EditableList())
</code></pre><p><b>Demo:</b></p><p id="demo-editable-list"></p><p><a href="https://jsfiddle.net/gh/get/library/pure/vanjs-legacy/vanjs-legacy.github.io/tree/master/jsfiddle/tutorial/editable-list">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="stateful-binding"><a class="self-link" href="#stateful-binding">Stateful binding</a></h3><p>While dealing with state updates, a user can choose to, instead of regenerating the new version of the DOM node entirely based on new state values, mutate the existing DOM node that is already connected to the document tree based on all the new values and old values of its dependencies. This feature can be used as an optimization to avoid the entire DOM subtree being completely re-rendered.</p><p>The following code is a snippet of the <a href="/demo#auto-complete" class="w3-hover-opacity">auto-complete application</a> which leverages this feature to optimize:</p><pre><code class="language-js">const suggestionList = van.bind(candidates, selectedIndex,
  (candidates, selectedIndex, dom, oldCandidates, oldSelectedIndex) =&gt; {
    if (dom &amp;&amp; candidates === oldCandidates) {
      // If candidate list doesn't change, we don't need to re-render the
      // suggetion list. Just need to change the selected candidate.
      dom.querySelector(`[data-index="${oldSelectedIndex}"]`)
        ?.classList?.remove("selected")
      dom.querySelector(`[data-index="${selectedIndex}"]`)
        ?.classList?.add("selected")
      return dom
    }
    return SuggestionList({candidates, selectedIndex})
  })
</code></pre><p>The piece of code above is building a <code class="symbol">suggestionList</code> that is reactive to the changes of selection <code class="symbol">candidates</code> and <code class="symbol">selectedIndex</code>. When selection <code class="symbol">candidates</code> change, the <code class="symbol">suggestionList</code> needs to be regenerated. However, if only <code class="symbol">selectedIndex</code> changes, we only need to update the DOM element to indicate that the new candidate is being selected now, which can be achieved by changing the <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/classList" class="w3-hover-opacity">classList</a></code> of relevant candidate elements.</p><p>The generation function <code class="symbol">f</code> can either return <code class="symbol">dom</code> (the existing node in the document tree), or a newly created DOM node. When a newly created DOM node is returned, it shouldn't be already connected to a document tree (<code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected" class="w3-hover-opacity">isConnected</a></code> property should be <code class="symbol">false</code>)</p><p>Note that, when the generation function is being called for the first time, <code class="symbol">dom</code> and <code class="symbol">oldV1</code>, <code class="symbol">oldV2</code>, ...,<code class="symbol">oldVN</code> will all be <code class="symbol">undefined</code>. Thus the generation function of stateful binding needs to handle this situation as well. This is why in Line 3, we're checking <code class="symbol">dom</code> in the <code class="symbol">if</code> statement.</p><h2 class="w3-xxlarge w3-text-red" id="the-end"><a class="self-link" href="#the-end">The End</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>üéâ Congratulations! You have completed the entire tutorial of <b>VanJS</b>. Now you can start your journey of building feature-rich applications!</p><p>To learn more, you can:</p><ul><li>check out a list of <a href="/demo" class="w3-hover-opacity">sample applications</a> built with <b>VanJS</b>.</li><li>read the in-depth discussion of a few <a href="/advanced" class="w3-hover-opacity">advanced topics</a>.</li></ul><h2 class="w3-xxlarge w3-text-red" id="api-index"><a class="self-link" href="#api-index">API Index</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>Below is the list of all top-level APIs in <b>VanJS</b>:</p><ul><li><code class="symbol"><a href="#api-tags" class="w3-hover-opacity">van.tags</a></code></li><li><code class="symbol"><a href="#api-tagsns" class="w3-hover-opacity">van.tagsNS</a></code></li><li><code class="symbol"><a href="#api-add" class="w3-hover-opacity">van.add</a></code></li><li><code class="symbol"><a href="#api-state" class="w3-hover-opacity">van.state</a></code></li><li><code class="symbol"><a href="#api-bind" class="w3-hover-opacity">van.bind</a></code></li></ul></div>
        <aside id="toc"><ul><li><a href="#dom" class="w3-hover-opacity">DOM Composition and Manipulation</a><ul><li><a href="#your-first-vanjs-app-a-simple-hello-page" class="w3-hover-opacity">Your first VanJS app: a simple Hello page</a></li><li><a href="#api-tags" class="w3-hover-opacity">API reference: van.tags</a></li><li><a href="#svg-and-mathml-support" class="w3-hover-opacity">SVG and MathML Support</a></li><li><a href="#api-tagsns" class="w3-hover-opacity">API reference: van.tagsNS</a></li><li><a href="#api-add" class="w3-hover-opacity">API reference: van.add</a></li><li><a href="#dom-nodes-already-in-the-document-tree-can-t-be-used-as-children" class="w3-hover-opacity">DOM nodes already in the document tree can't be used as children</a></li><li><a href="#fun-dom" class="w3-hover-opacity">Functional-style DOM tree building</a></li><li><a href="#on-event-handlers" class="w3-hover-opacity">on... event handlers</a></li></ul></li><li><a href="#state" class="w3-hover-opacity">State</a><ul><li><a href="#api-state" class="w3-hover-opacity">API reference: van.state</a></li><li><a href="#public-interface-of-state-objects" class="w3-hover-opacity">Public interface of State objects</a></li><li><a href="#state-val-is-immutable" class="w3-hover-opacity">State.val is immutable</a></li></ul></li><li><a href="#state-binding" class="w3-hover-opacity">State Binding</a><ul><li><a href="#state-typed-child" class="w3-hover-opacity">State objects as child nodes</a></li><li><a href="#state-typed-prop" class="w3-hover-opacity">State objects as properties</a></li><li><a href="#state-derived-prop" class="w3-hover-opacity">State-derived properties</a></li><li><a href="#complex-state-binding" class="w3-hover-opacity">Complex State binding</a></li><li><a href="#api-bind" class="w3-hover-opacity">API reference: van.bind</a></li><li><a href="#polymorphism-between-state-and-non-state-dependencies" class="w3-hover-opacity">Polymorphism between State and non-State dependencies</a></li><li><a href="#removing-a-dom-node" class="w3-hover-opacity">Removing a DOM node</a></li><li><a href="#stateful-binding" class="w3-hover-opacity">Stateful binding</a></li></ul></li><li><a href="#the-end" class="w3-hover-opacity">The End</a></li><li><a href="#api-index" class="w3-hover-opacity">API Index</a></li></ul></aside>
      </div>
    </div>
    <script>
      // Script to open and close sidebar
      const w3_open = () => {
        document.getElementById("mySidebar").style.display = "block"
        document.getElementById("myOverlay").style.display = "block"
      }

      const w3_close = () => {
        document.getElementById("mySidebar").style.display = "none"
        document.getElementById("myOverlay").style.display = "none"
      }

      const tocDom = document.getElementById("toc")

      // Track the current toc item
      const trackToc = () => {
        const allHeadings = [...document.querySelectorAll("h2,h3")]
        const currentHeading = allHeadings.find(h => h.getBoundingClientRect().top >= 0)
          ?? allHeadings[allHeadings.length - 1]
        for (const e of document.querySelectorAll("#toc li a"))
          if (e.href.split("#")[1] === currentHeading?.id) {
            e.classList.add("w3-opacity")
            const {top: tocTop, bottom: tocBottom} = tocDom.getBoundingClientRect()
            const {top: eTop, bottom: eBottom} = e.getBoundingClientRect()
            if (eBottom > tocBottom) tocDom.scrollTop += eBottom - tocBottom
            else if (eTop < tocTop) tocDom.scrollTop -= tocTop - eTop
          } else
            e.classList.remove("w3-opacity")
      }
      trackToc()
      document.addEventListener("scroll", trackToc)
      addEventListener("resize", trackToc)
    </script>
    <script type="text/javascript" src="/prism.js"></script>
    <script type="module">import van from "/code/van-latest.min.js"

{
  const {circle, path, svg} = van.tagsNS("http://www.w3.org/2000/svg")

  const Smiley = () => svg({width: "16px", viewBox: "0 0 50 50"},
    circle({cx: "25", cy: "25", "r": "20", stroke: "black", "stroke-width": "2", fill: "yellow"}),
    circle({cx: "16", cy: "20", "r": "2", stroke: "black", "stroke-width": "2", fill: "black"}),
    circle({cx: "34", cy: "20", "r": "2", stroke: "black", "stroke-width": "2", fill: "black"}),
    path({"d": "M 15 30 Q 25 40, 35 30", stroke: "black", "stroke-width": "2", fill: "transparent"}),
  )

  van.add(document.getElementById("demo-smiley"), Smiley())
}

{
  const {math, mi, mn, mo, mrow, msup} = van.tagsNS("http://www.w3.org/1998/Math/MathML")

  const Euler = () => math(
    msup(mi("e"), mrow(mi("i"), mi("œÄ"))), mo("+"), mn("1"), mo("="), mn("0"),
  )

  van.add(document.getElementById("demo-euler"), Euler())
}

{
  const {button, div, input, sup} = van.tags

  // Create a new State object with init value 1
  const counter = van.state(1)

  // Log whenever the value of the state is updated
  counter.onnew((v, oldV) => console.log(`Counter: ${oldV} -> ${v}`))

  // Used as a child node
  const dom1 = div(counter)

  // Used as a property
  const dom2 = input({type: "number", value: counter, disabled: true})

  // Used in a state-derived property
  const dom3 = div(
    {style: {deps: [counter], f: c => `font-size: ${c}em;`}},
    "Text")

  // Used in a complex binding
  const dom4 = van.bind(counter, c => div(c, sup(2), ` = ${c * c}`))

  // Button to increment the value of the state
  const incrementBtn = button({onclick: () => ++counter.val}, "Increment")
  const resetBtn = button({onclick: () => counter.val = 1}, "Reset")

  van.add(document.getElementById("demo-state"), incrementBtn, resetBtn, dom1, dom2, dom3, dom4)
}

{
  const {button, span} = van.tags

  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))

  const Timer = ({totalSecs}) => {
    const secs = van.state(totalSecs);
    return span(
      secs, "s ",
      button({onclick: async () => {
        while (secs.val > 0) await sleep(1000), --secs.val
        await sleep(10) // Wait briefly for DOM update
        alert("‚è∞: Time is up")
        secs.val = totalSecs
      }}, "Start"),
    )
  }

  van.add(document.getElementById("demo-timer"), Timer({totalSecs: 5}))
}

// {
//   const {button, pre, span} = van.tags

//   const StopWatch = () => {
//     const elapsed = van.state("0.00")
//     let id
//     const start = () =>
//       id = id || setInterval(() =>
//         elapsed.val = (Number(elapsed.val) + 0.01).toFixed(2), 10)
//     return span(
//       pre({style: "display: inline;"}, elapsed, "s "),
//       button({onclick: start}, "Start"),
//       button({onclick: () => (clearInterval(id), id = 0)}, "Stop"),
//       button({onclick: () =>
//         (clearInterval(id), id = 0, elapsed.val = "0.00")}, "Reset"),
//     )
//   }

//   van.add(document.getElementById("demo-stopwatch"), StopWatch())
// }

{
  const {input, span} = van.tags

  const ConnectedProps = () => {
    const text = van.state("")
    return span(
      input({type: "text", value: text, oninput: e => text.val = e.target.value}),
      input({type: "text", value: text, oninput: e => text.val = e.target.value}),
    )
  }

  van.add(document.getElementById("demo-connected-props"), ConnectedProps())
}

{
  const {input, option, select, span} = van.tags

  const FontPreview = () => {
    const size = van.state(16), color = van.state("black")
    return span(
      "Size: ",
      input({type: "range", min: 10, max: 36, value: size,
        oninput: e => size.val = e.target.value}),
      " Color: ",
      select({oninput: e => color.val = e.target.value, value: color},
        ["black", "blue", "green", "red", "brown"]
          .map(c => option({value: c}, c)),
      ),
      span({style: {deps: [size, color], f: (size, color) =>
        `font-size: ${size}px; color: ${color};`}}, " Hello üç¶VanJS"),
    )
  }

  van.add(document.getElementById("demo-font-preview"), FontPreview())
}

{
  const {input, li, option, select, span, ul} = van.tags

  const SortedList = () => {
    const items = van.state("a,b,c"), sortedBy = van.state("Ascending")
    return span(
      "Comma-separated list: ",
      input({oninput: e => items.val = e.target.value,
        type: "text", value: items}), " ",
      select({oninput: e => sortedBy.val = e.target.value, value: sortedBy},
        option({value: "Ascending"}, "Ascending"),
        option({value: "Descending"}, "Descending"),
      ),
      van.bind(items, sortedBy, (items, sortedBy) =>
        sortedBy === "Ascending" ?
          ul(items.split(",").sort().map(i => li(i))) :
          ul(items.split(",").sort().reverse().map(i => li(i)))),
    )
  }

  van.add(document.getElementById("demo-sorted-list"), SortedList())
}

{
  const {button, span} = van.tags

  const Button = ({color, text, onclick}) => button({
    style: {deps: [color], f: color => `background-color: ${color};`},
    onclick,
  }, text)

  const App = () => {
    const colorState = van.state("green")
    const textState = van.state("Turn Red")

    const turnRed = () => {
      colorState.val = "red"
      textState.val = "Turn Green"
      onclickState.val = turnGreen
    }
    const turnGreen = () => {
      colorState.val = "green"
      textState.val = "Turn Red"
      onclickState.val = turnRed
    }
    const onclickState = van.state(turnRed)

    return span(
      Button({color: "yellow", text: "Click Me", onclick: () => alert("Clicked")}), " ",
      Button({color: colorState, text: textState, onclick: onclickState}),
    )
  }

  van.add(document.getElementById("demo-nonstate-deps"), App())
}

{
  const {a, button, div, input, li, ul} = van.tags

  const ListItem = ({text}) => {
    const deleted = van.state(false)
    return van.bind(deleted, d => d ? null : li(
      text, a({onclick: () => deleted.val = true}, "‚ùå"),
    ))
  }

  const EditableList = () => {
    const listDom = ul()
    const textDom = input({type: "text"})
    return div(
      textDom, " ", button({
        onclick: () => van.add(listDom, ListItem({text: textDom.value})),
      }, "‚ûï"),
      listDom,
    )
  }

  van.add(document.getElementById("demo-editable-list"), EditableList())
}
</script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript" src="/code/diff.min.js"></script>
    <script type="text/javascript" src="/code/van-latest.nomodule.min.js"></script>
    <script>
      const copy = e => {
        const file = e.previousElementSibling.innerText
        const importLine = file.includes("nomodule") ?
          `<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/vanjs-org/van/public/${file}"><\/script>` :
          `import van from "https://cdn.jsdelivr.net/gh/vanjs-org/van/public/${file}"`
          navigator.clipboard.writeText(importLine)
            .then(() => e.querySelector(".tooltip").innerText = "Copied")
            .catch(() => e.querySelector(".tooltip").innerText = "Copy failed")
      }

      const resetTooltip = e => e.querySelector(".tooltip").innerText = "Copy import line"
    </script>
    <script class="inline"></script>
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async="" defer="" src="https://buttons.github.io/buttons.js"></script>
  

</body></html>